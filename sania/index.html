<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"82d8ef7f81c0cd8c0c730ded7a94221e2cf57a8655fa0fe0d00ebafa797095102826c09d75b26c7c24a7c5ff8e1e346ac8e15341ffb0c51b134595434d610d22f3af3abdd11ce73785fb120f8a9c2efb635eae6633e79084f615f9b2bb91b8d4411e00d725a585c7b6e15757750a6bb5d110dba9d5f45315544f3dadbb3f8ca2eeca2461dab650d8f901cd401796f1035526f8185e6b5939bea3fb96d093943f57bb758200388503e687c1b7e26ad7101ce1792b20534e9eb07bef8bb265b3ce0db3fe54a3a07fd6d9b630dcb9474597926a5d0699219d33a1e89623557c750e26ed4f6449baf4faa0aba22a501bb3a6f40a32642d0145afcea7fb5cc43704e058f494ebb84c0c050e4d34806bbc318d46bc6c58f522a4b91a7a169e4a53149c2be9dc9e45c341e056cec7c74e060e62bf0abe14c1f13b8f134b33615b13d109be7a21730c3b9294678e00bcef85a41308b9f8edfae753b7a47e14f524eb713aa761d071171872b785c1029bd5b81838f6d7bb1267f7b29366ef87532481a4967bcceaf879b178783d718d765a01a771f7bfc6497911201f12c6643346d9a1e7c0e7f654319688de59f027af185f6cfeb4a67a3bf285f922f9a3992a43e63e49488893720d387ad6664c6538b458c0ac79b311dd16b05073a88970a161c1c2e2ca0a3650cb266479192196bac1b9a0bd99b9778eb037dc675df606d91f2a11d43af686f264683acf398418f5623bf675336e08d021c151805355adbc86cd506fe704eecb6a68bdd3b968adea95bf637f11f6d36ecd75ca9d3c85a4a40a14e5cfa98936d7195c73282a7ecb65a654d8cd0bd69bce7463ec0afee0e7fc6828eabe542884a69ca44c30978fe5a903702100ce2e82910dd10462bd3308adb08d92e7a54c984a5a976b90231d4165ce840453aa00c13485bddda0460ee4659297cff234fd1927368483b39ed1321a384ccecf57a1bc9937368495d0fa4ca61f2cb73132a3d150bc519021f0e8161284170a1ab3abbf2a0b073cef5ec16e6ce1558f4c7d58254c8513c021a7306e797d85d755248e2a526759d459e769b539568135b76b8677dfa450093976db79cf3a5fb1865298848b05a1bb41cd7643c4705ef6b5d863a41dbe3d39fc8def7cbcbc77c69c33f4faa3ec667572eac7447043af5cf7d8643dfda4cf8bb0cccb6f31a4fcb504a73c16a61505718c7865268c058af3ecedc7d02540d59e9ae6ae888043d5b8a4ef23b769d9a4c0e0b06b092ba2d87091043e89b499352137ecf0df3a007b86de980805c4794fde3b9296e780fd9e01aa0bd720334b5e872be59452aee128d2b5d2790dbf833712e681cd05d59044db070bf9fd4a72e5618fccfcfcfab87595756652948473ed0ed6790f4c8f80f987fce5ebe5972f7eaedb691423fc0f051ec8b07e7b4f19544febb61a7bbbea027ac8ca071877a83b7eedb06625974bffa761ef3c8e147d85cb6979e02be94b08ec9169c4d848a36791915274c1e2d796beb8999c892821cade1921a38ee8460df9e536b2d232e000008f894f400838bd7a70542b70585f67a57768a1902f9ebbb878a1a1ccb49816110b4ce4b84927c73ab0aee6a51ed8e9c93d1ed34fce1456faaecfd8f59b71809de96e4d0aef6ea343a20fe262cfadba3982b970ac17b6e63eb27057b8b9de3c3ba2fa60a324115bd7ce1d2e82cd76ea80b96f931faf825f6fa28a6fdf805ec8381940b02b7906448c0653a0013b4bf6ceba1e8a56acecc2692d427467acecc7c5b4c75b3fb7cf7b6c13dc3f9256b6a808afed324f0d33242ff0055593f073f6346c2377961fb8b21b8d205b9e88a24c5db8f8eb8b46ad597a1b2b3ef35a22ea0a1d045827cc0488ad9e8dd98a5b6fdea483511a91794dbcbdefca7ecd2997be7b7961ecc7627ad598d6de425d299e5e3faede869e8794a8ad7ae2d5c45e67a124f67278c6c8146bda5523983a9aa82847a141fbbfaabba91790a654f2d0ca73f9668a056195880ac6113ff778585c5421d1146fcb4c93aac4bbbb27aa93a34dc106b4f5aa15e2ac99f3af958189511226a628884b5792e1c3c7adb07a3ec5cc95bd085836b4ab93a22c7bd6776db6830b6131fd5666337e16567a143f2df2d95410a97987e0ec3c8a6cf308fdcb54777d9d328c232251aad170321a691e6c2a66fcf22cb494041ad360728404878648099f0f12ce74c29d9587220101295d3a6518ec5eed9253e66288b1db993dc1d34db15cdc8ac1bb36c8b28e77cb82add5b0c1a7916272f7729d7009a1b1009fb702898e2d5939f4825ca2bb65497bb49b9843e34a86fbc6cd38bad2c5019e08b381ce6f86c00b0527464844142a4a9e4070f4d293db030e5ecfe08d27d405dcb6961d752cdd139731e5e3db0399f44f75e6c45ef00e8a3214f7876084a670b7d6c6d06565726b58b1128bf2894fa6492ada2c52ef6e1335b3be865b116c3b63c218ee95b1ec7daab8876057d1ac2f22aa527ba86cf22da4bef8a65409651c98c0074d3b46f52886500684b2b952a514548407600e0e917db5a567c4b3f64b122f8ae0d0d49c0f28db21c35dea7705010fd0a741141dab1db75cdde7d1f46f344ff136ebe6897b938cad52df5d70d1fd2734266144cb7619fbf23ebdd53006a34d57599ad2c531a04870cde9be6f22709dbecd5d11b8e6ac30d0c12c4d7d659c7a73d2151bd33a4ef4fb2078db198b1ffe0f69931dea6a82bd35afc363fd3f24a1c3d651a78a954d983fbf1bbdbb17423a95b33f0ff95c56216b6ed0a86938cc839ff85e1643f011c28ac5862e2249e304bc82fc8636aa2ec92baa91f4d25a2d07971feb2779db99c495ce6347ff440f8fb7b69e028f5e83012e04d3fc31552784c202302915927d9dacfab344b42643b49a9451dedff767c5469c3f79d5ac3067b83fef7ecd35a75ffc317be2f40c8a537703d7155b71fbaed840149b167bdd2b1d69714a33c1d16bbaa2c20ad529ce395ad8d18dfe7e9d7f8b7e8259de0857e43b10ed7e8ffd0c86f4d6f9337366fe6ec87861331adeba76993cb6a0fb37d1763a458f35dc2ee020538c67faec81406a53c70dbe66451a015cd9d57f44fb110effad25b37c45b8622b1e88f254ebdf91bd0f12a36e4cbddc306c24d95f14eb376a96e2d287147d01e6fc5273b81c5fe96d01b8f6c360649ec83ea3b97e83d2d995ce557855383729fc2675487c0852a94d4e45598db7f9eff919399221cbd99ba5647d25c25fcc44422db5b2011d6192d3f5954437df8bb748291bc5f61c8d5fddadfb05cc5bf56933d6937232c9cfc55932e40610908b1ccebedcf47c1a3a27444dbf46e6f429ea35e5a20c2848aa6521e830a0d8b68edf4f697d1226369bc6c3d8dfb54141ed118465626566cb8d7399e81590df347e979a1ec8cc09dd1c895e0aafa82106f9d8b5ec27f1fded191618ee4a5a3ffb3b1998ebcda71b7330e0c491eb3538fbf83c90d34ec0f41271b99990ed31a49983c1efcb3c854588ca5870a9ebf4240f7477f7a1bd7f1ea911b03a8be9a59b06a37977d04c81e1296e46fb22a035a4995e672ae9deec38a1516dc646edd6abf35fe4deee0bdeb7e794549d05952d0aabaeff4f67f45c56228ed62a758912485b6f70fb8540dbe243cd13f76c57263a3d23a8dc361de449881626d57fb2550d27587fbd0fbb0d856c13ac2988d773f2aeb2434c42a1d8b2173ce128d259586363a0d19211ac5b3537f8cd39b884a2ed5348fec257e3ddfde566b2789a886fac4fd06ba406d0b35d18efcd474bc4ebd162323dae823e457c53290adcb003b19596458911ec6d0e252235f1d35c3bc1072dadc4159e9bc7c428b302664be21dd3cac866b1a5043d94780c436b4d086bd7c871d9195bab7c12160c7ec1298bd54d2977070a729d5a4cc46aa76f2835a4af56c8c8f947d8bec13bb2e507444a71f9fd5f1f23d34aeb788d6c589b4d9569fe1f6d03561242ca3a067a99acd347637dc1dc4f831f895d957b773f9041adf68787a63d324cb68d068e7b018717fad007535baf0d303dbf2fdf4dc9c71292a2c303195fca82c7b551f4839a4fba09d20aefefaac18ce9facacaebe71d5ae2e65833e4d380ae61c59e9488d4c3603a0b2cff8afb8c896a522a9902997d970d40da01039adc4778014fba816720351c3645b98326ef226e481cde829fdca380f93e42230d19574d29379ecae1ab6ebf036fbeecb61eab31c788ce6362b8345e2f54c642e35285b45f3e36591dc93569e133a60e3fcadda637c5bf0b44d1a7215a9b26c1b769f811e9810ae7f53cffa3a4ebfbfc80d89e5e9c0999a503e330ee63e477a7f221ba828d326840d03e54bc53ace69dc48bf679ceaadcc1f23f812b6ca15e2296ce375feef8a2a021515cf770910b19cd1cc01d0d23b84c33317aacc5ad1c61044efb6dd2fa7fb626728478a7a127257f35a0af249103e90c9972b9903105c776cc8f590fe30e18e6c069b93c5bd58e76e8445acc3477d62f23387649a2167338f766ca648e86d005341315522b7b108fb913f4a378f5772a829f4a9ce37a7f704c641e9de7255b6d43ba53642bbd0d5625efe1c2b14ed5a049857e5c7dcaf1903406f1c941aa50ed65ccdace55bc7a6ee2ad2a75f3e5ec8a25a8cc71349ae009d0a1990102c87947ce896586dc92333fca4d30cee3c2214bdb77184e81ae348d13a88589d341362c43fe6747862ca94ee910afa910df6be344cf0ed196dd49f1ced15ce4a8ae0e0b33016e71f0810e37601a5acf70889cbe7e610d65d7d8d66a7c6126472c1d981004a21fa1ef1befd980afed199371b0d0ec01da84ed974a5862710882a08c489823d4e6d44f6cacab4c92486caed1845c721c6fb2266fdb547257db5ec6b29f2354cc21b75bddc5a329c8c7145f200ce2008503f2d27f8172c4fd86493160bb8b1db51ef1049246ff7652a97fe4eb8f315aad075964a1815bd403eb3c5cc4203b3a103c76a06358671569b81606c4c8e64ea8652d1d250270ada59e94f41f5ae217fa2a24e4c5cf22c2f1d1555a62dc4ef97b87a0b2b9dc8eba5a10ac5f6b029d12f1e0b73ddb33cfe5c873a0ef11d9d82060c58246bbbd871d24c46dc2e6e5128c372ef56d906ffc46140a81a64ee5f9272183e3d439f4fd51dc4c7702c8f8af3c8ea00f970e675c8cbc1076bb7137cbc21439951cc5e0c56b7b0c64b2b89be3388c575b30d931c8202c8820faeb50f4e188dc5c4ec2ea470a07bc3ee3849af312b37786e9fd0dc559735573366815ee4e8ca7d643d7a6b300de222d86365a3aeff496ceb0b5126e35f17cf9e843c203841702945fc87c0b0e6208e1de05fab905694495c2ba3d893dc6affe368112491693c2361f930921b7b92453cb7149f6c8115662668cf3f0723cebf3a730a88af78fb2f703aae8e0a10fbdbba5d2391098567b3ad2b317c226398c9d7856c2a08987c21747eb0be89a4ca299aa2a967f923336e01fe995e8f42b007904fb22922ca1eca44907a8d3aa10bad56257a88d5e5761313ea4240d6b387dae70b7fb107ea23fd96e561b97e2d2fe09d361f21638b7bb6e3344879f158f891d315b1b94229bddec4576b228691028fc7302a02c1a73edf6aafa508a0f78998f531745268340b99e350f2af5b66a87d01829a376e49fffd487b7974fa2a6107d9962ab10a5b6fc9fd23faa95477e50dcb310cfbaa267238ecfd25e2dc7fb74f61d6d4490aa7fa7a8bf59d2365b3be34e9278593607dbf4a1307b2e456f4e8c04990309d7f1f8faa93fe1c2276289ae22c8350dfa44f3777d5a6258b29d2cc28c0791d354db3d639b932b3644b0d6539ef8d298b2e35200d13d2e41162f24e02ea8d9ae16fd42b7daad2dbe97224772e064d0baab6dee4dfa1dd8629d8e6f746a7a1aa9e1edac4872f746e132d0549ee7ab28d9af521c3026b54a7e2ba88f32ebb91bdc7f18c6780f4a8fd9dd6c8c98813657fef7b60d3e1d66b3587b33fec3d0a91ae58a012322fb64a13f2a8344e5da917c5fe6c6eb2241a46ce43a06f1c86fee9d79df3635262c5866de099fbb62dd69296da625a545c4274dedaff5fa9fba630c2cbd655fbc9aebf74f34735238551bb8475ee15fe0d19d094498a06e454c3022c2f3eb34b4ef86a0d0c56a66296c4f8a406537f7df732f43f11873650b2404b9b98590bcd0f085d6f77664e490b3eb4e676af7db251cdf70e781c95c2d23baace1dcef7f2af9e2b5a42dd018c2e5a7f9c80c805d289ef49c45d5963ae41d75a72ff113f8ddb3c1e98e6d5e846d4532d3fca683085524ff34de4ca1f3fe4f958fdfabc5014dbef636c7daa32d39ef2746bdcd540d25e779fb23bcec8a93f876706607d516127faac4631088f95f734f05b2271f3fc1c227ca865dae54ceeeb7adddf89e74cd36ef8804c23d776b7dfef1373278e3a99d94c846ab35f16a90c3c4f3a8c43f35da81909777410f40de29c62514dea7e01a408757ea655e1c57422283cfecb5c94721cd80d4bfa21ce0b9d0fee42164d0ef069047a10ac57c9afda9757c9d1ff5eee4cc65084e49d1846eb59981fc21762bd9e19c61e087a5d75e130bf4e0e2f1ad233a7de8b61ea49b075180c1b366f4214cc0dd383c27aaba8709fa22ff7c23af3f672df674f46baa9768e0ec06d7a14dcadb3879261dc16acfb14f2b2883b39de8f5b730d2fbb782688d2be8cb6ae8ff4cd67dceb556ca45176cf35cc0c2e4a34150e2dbc1fec1db5d350f0a0645f89614e6587df8fd505f3d0da7922aef33ce48826ab97d2112958213bbb28e9f7f102626fdbde486cb217abf8340a92fd7367eb68731b8a4f48ed6a7d4a2529ef8b23801589a1ea627ab8b965cda352155f7dca9408b2528bcfcd9e897ffd8501b1ff7a0d0277cbfa10b2e176a87bc013e094e19c3d82822361872b733afcbd3ccf8ce9c7f2c19f7623ffdd70b043ce9f07a1b642ed8df5ea6428a5ca8fa1869c318dc6db92fa5606b709044685846ecfdb7a975e4be7c1c6b35f8b56a6655ad8f92185d0dc09374b9b48f98b96b1d6ac7d9ddd6d74cf1f995201aa4a754a8e67c219d3d9488951d7cec01b905c72eab525f195f5ce750cbdd7a2c4c1a96b3ced21b5a93a61f76d7d5fb511048b68b079edc27ff02db458af1bd922db14cc98d6586a2d2bba918836f4d0d26f93011a3ff453bf006facc431e8ebf798b2f97239ee77ce4bced405f00fcae0ebc7047fac9587845d5da18c207710e72e7f43356c5b2dd498b85dd6f1b99029767199c2dcd64068b1d0aa70d875820a62eb5b0d03fbaeb63345434b0d8781880ef972ce8edb9467d1cf594da1c736815a1f88fb6606b73367424ece637dbc6cd34f71f3a229cbbbbb201995d095d437ccab73be6979690413001db9ec5b4342d5fffe7cf68b55b911c79254ca033b103eb4c3e13afce04efa3c0231e8c1151cdbd4c0da81b6cd59da626055337c265047df1f6c0d3dd17e2331fe8df0dba37c808d6efed1ff91a9a8e6d71007146db7d33a3e9ab7cef9909fff49ce1bba142a39b2e9757f9856994673a6ff49546eb0cf5740c815f63be06665bb6e3cea277a5cf88a98eb8a391e1ef483ade25ad2abe143acacf4d143a3786078b91cfd433f4b79d01d6cdb0487a0c99530ba0da57107a0be20ad8dc1fb1d2b0a7eec7e8dac1cc82929ed88124212f63d835dfe40cd854e59441d7c34eb54fedc34af44448a384adee665dd6c3eda12e2f60f367980bb7a0e40271ac66bdc00f84fb647197b8bdb31ece48e64281e2dc49defd80e9603e2813b3fdbec92411d139cbd1c043dbea3e52c668f6fb49b8d303f752b187484ad9810611bf0c5bd8e54f36fd92a061e05b5f7ae42314fc86b4c7fb6be208738f032e08ff48e3b3f7fbc26a6e2e4a3baaa0ce25ae336262f9d3040cf08837055297e56ecc84c2128e1b03b5b2fb9911a88b89d2785624febc4b2eb9e5e9373a36b2a39c3020bfef72c18dd90e3ed71e60b9f84b3bf6f37e3874cc779dfa84974381bd8279278a2f672acef152bc1dd293fe181e920eba4ef5a1f77bcc800ea5f71471e004ae198cac03e2b403e6ad7d6f05f45b4c78d440cf9164b2a77fd51f59da82acc844e872395d46d080acf548e5d4e492e901c23f70dfec477ee35d60b6785becc8658f6e582f17d067ddc201a55f7b3e9eb41017353c39ac77da81fafc0bd48441b3ad651ba8c2bb7854ec10ff8d35fcb2989096e6e1cdebbb631786a5669d4321e485290c5d3f92b9d5bb870d19c64d922bc00abc4518ced8d11726ff37378c1a54ea76a5934a0488f37be2079ac8743de870d89351c67940ef7ff8da3fffed83a1162f1fc256bfc3b464d2d2f292c48668f1c412ad1613edec9e59e72a7b969e590a2931720c7df2a6e669900e2f4544f1b71b10ee892a211ed2e9cd13e7e03fef007ca5cfff88ce12ffe1b413b783b9a56f2440d3c728ad1527439d1cc28ec2bf4bd171e96bea6169cb9c2cbfde82a83c66ab0b38eb43a238cb179d38846f820a569365873b08ee5e322ebbe4bac953f8ae681325feb1d2f02f6ce79b271862ef8af5b94084f619d0f20daf5c7bd009c67501cfbb27ba0fb82e712cd487a8c62759fbac32398e7477f5a969750007abb2271767a7d2e788d372a54260775d8ef78555bb09ce492bc0d6d85af98ae83cb5a9eb78e49b6e16dec8a33c366ec9176fcf0687f90fac2659b8dc081cb2e3fea6b4727fa976a3fc7f1ed987736443724ce16f4c43b7870b207c5c42c36d69c0b7103345d19e73da859333d48ed0ab1cd46de8bad068f7779d2b01c71226b1695dea8cd6687f0c2c0fb0f149c4b790ea84003ea1087a39e75b00a61033457e1fe71c97ab748c7a9f3b1bd72c568544a81fc890093161fdb447f912d3c191b47d37cc1e78f4171b689447ab631919ebf172d300667fbf2a8ae906344facbae4f53d10bf72046e9cc140b90522bd927592870a904ad6f344387cb99a52f716d501b9f42342540ee936c65c0fcdc5848aef977b7af4752e494d54508f52752dc78075efb4bbefb1e8e409145d035040811b2947e70f9567d0d7c5aefd8462d9ff6e1fd12988f6cec275c24e18b408d2cd280badea39a032e8006626e004ffaebd2f82e3402ee972bdafb0bf919461f4cc127cd4d490891b57aa44ee2e2d70bd2a2112d68db15222027d486e6f46c85d63c4a3002f6a6ed9be4a254986c62c4c22ac095a3a8fe87167e3b7aa16841df16d4f4e3c428e3841471d8d076f3449b3b736d523b70883c9dd3d06a512abbd162d6b010e75b225550b30a4de25e659bbaa72b714761b24fa5a35c74d2cd1c132e0ae73b26259fd2a060e65fc46c8af32d9a2480db5f60f8f352424f7a6e4cc7bbdddf020cd4890983b92047fe444e58eb636c765a55d766f3f3e5298c3f84920fe991689433878b7faa234ea5c76e0d2083bed4e2ea22c7f393fb09f40998498d4d74c231c72f63bcb77ca3d327075aaf4d250a57cc9b0b062be450559a5c0c75a9cce5bd743dd5bf6b22a1d1dbad074e316012d017fc18a7d1db56c3224bdcadd70c717e50b4c89052ed6244994ae0fc4839adf48c11cd23789d3eb70d5a15c956e7c9412f0d7939df5816848e262b12c58cb154d906732abcf2ae57c8825692339df2a67019d442b8474434a55e1366c3241fd8b8b70aef5ac271b27c0eb56dd3c7370bbd4ecb4d2779fc4ca98d3e6025122544d98e5776009f6486a40402dbc9ecf1a6027419fa034234871718649e405e3cc61da97e878064332f22b152e2e157965024720db200acfe7183e0910c6547c4355221da39bbdc7e9b9511030e35870234780970fb316f0578cff5fd95ce0636a69285b5cb714578d731b9c0015d2c336e68821c37b4ca610463d6d04cbdbdebd99ecccc3c90ee277f87e7e3285892c2638e7c6d1169116510873d4ab5de0847295db0deff3cc74ead69dd0f8b2d763c752ea68e6be24c3fedc8926b7130440d5b253bd33b3a9403602525bbcb243d095732d37d35046d5fd3709b91669552aa710db0aedf097eb578ffe59a1d36db69b0852be42d1964494e689cd174b2eb4d72fdbe2fc6d14385e5dda04d027701e445ba27594aba05993d691626acb7488f9bc044048edc866ea25eb79a25c501ddda5b08ef7fd1614c2fff7d4bac6996467dfeae8608a8cdaa49988fcd356138d207a55104e70a21141bb26b56b3fde81202f1a1e2900071fab213cfd75e20c3e7cd1a7ecab1f866a92e683266c9687c9f3f3d94d91ee99b0eca7d3c9aa18e5a8e9e498464b688437e49dcb34b3cc2bf3a29d30d4e42f6486b1a35d33728b384e0986f95a08024ee172f9b509d4933cf65cc637efd9350acf7e3a7b51c63ff8ccb1261d501751af79871be77778c3bea5851bdab159e988218444b00590cd7e134fc0e65de2ba0868f78bcc966e5dd3fa80c87500c963b324885c44a71073d17950139003e9ade4d1fcab8b41e408047df92ef95acc4f06e7e979cd26f007b094dfab08b8848c96ecd5ac56d5e1bf3328c9730dd23201d494d4d45a7a1ac2a5ab12d9348e4e8285a51478555c32d67f3a94fe1c266527102578b3b9503dbf2df446631d17ed5b834c82adccb9985b36d9e1b8eccde9121eeb90cf229be75edb28e9b829a6d7fc41b080db702bc214c98091d7cfb0f4099584c3d6b83ad77fc14556c164fd0fc45259ab7f4d97daf8a98e8bccf7903a878a646efb21c8fefcda858a021c6b2da4f2f02928eb6409423107bd932f93188be4ef5d140c36a62ed9301dc02cf0be6f36705f896a92db198964fb5ff8ce9085847399794d0c60bfaab1f51d7053472d723166ad77df39dfb7d1de369218c253c8c54865098027edc91b4803bbee2c44ac1f96dfb146acfd7b10ac04199902c43f44af3bbabf92cf2a9730791c44604a3610d663bf3e66c3f550ac4312c396092761589ec85ebd35d7d70c5c2d440bad3528442825d2093b190bf9cfca4e6c2c2c6efaf813fe071538d7aff39f59ed4a768a6ca7f4d611c2608b26822c84868f16b2d2ddd2fbb14579cf30c8cb1e79aef74c14bc8f9516bdd733e1adc1645fffe8cfc37d5f497416c3eaf400f0aeb28eae78b92d5ca1fbf0257439111d6cbd5a18b81e0e4db1921098fd8edb1bf05c28f6b750965accb13b3e3d1f3270ae8a4f76640068b3d7e9ed2a8b399ed4f819b946d435c38a8eb972319ee5bf41ae8f6593e527252b9d41c55b0c6467868fd8545dbc84af048cbc251004597ee2c459ccfb3209062aec555dcbde5d6118a03937ae01e5d19acc97936282a1267a3a19696ab4036ce8bf07cf00dba6bd301b26f50ea6b4d0c62d8d35701255c200a59086668dab88963be0d2683f14d52eb624f6ba43fee4eca6b0437ccd1751f98f021389cf55a2675d6112142b1c97fd0f2270dfd2c57bf45cd0eb0d5c54ed72901f6be8784bb4d9f01c51ed1c29e9e84bd0560f653d5dc4b89336e3fe0b3c0689339f3e23b552e5d81fe27b627ec0873d89a33d410469b94840d3cf5bb644716bc55ae64e1bb0418c781c3c7ce2c74952b07da6ef0ed8653f14934a7df192e27938f3deb9c0a1d163a81783a5249b4228d3ebda08bede9c9a0d5b6226552cdacb87d2f5bcff61bd9e915dd99de75cd0f7eb2ed9ccbe18d0fde77f1dd3f73c060b15c48a8d061e9f0f165614f2a38282e515e39d26898d641570ba5a915817b915e2cca44d5d6b0d3ca6b813cf8e35245afa3199502ce80378c21a14689bbfb4a89e852e1464f0e110da4ea78e7dc00df72ee4ed0d40661ee62245547f84635b5ecfd2dad43e53565a837e1e467c072db196fdf30a36b4ca20ec585c35e2579164cfbf26200f671ce4da2012e0f75ffd4e6dc0a81090d2483e877fb93fc386c5787e39f1d57b352db425ef4d38e912c1c0666baddcb5e5be12371b394a50b41f859159c606b30fcacfc81be6168340ddd72c4dacd6a772da4feb911a22cc07be9ec79516d205864051dcd0fdba46cf2d3a77ef541c5b7c4eb3ad7f9b99bb2e2d7bc30983f2f90933789ef28a9ee59496554f747bb9296404926e1f890fc1914e95571a597f2796a7047780eefccc2f9ad3e50983d3fc5c734bb462915087016f06eeba7a40f719c711e27daec091491df4118c005736dedb288df627e9c715c1f8aa6ebea641a5770f7a154e2409935788b1e4e21f36698eed58634bc699af726ba919203ee558f1280700d60e0e1b9cebb23fde0781bbf22967197f3bb55c3e1bde7bece4b539a77ab83d11051617eface6f5a830785d7b5eed4fdb3f18bb038032b1b84623e78f11a86778ce347ec5cad9af4edee17139738efb882b3fa023ed567529ab793f9600a790a16c5c1f54bf5e3ae423fd73c640c8602d6d27d7b71704a18a91c6e611c22da8fc7ab4ac91fd9bb1044f54a40c91e668f10ec2b24d44bc0d1265e8d53439811d6db821ae6ad084dc16e4b424162b53445d7a9b926f2a01bf05327570aff3bd30ccfc2de50493c9ed6e4d0205f2218eaf6b8b5a20545e08f58c58b8cbb4cf2a48c3ed9766f795717dd2bfdb5544b62fce0efdd1518f20774248354e215727b69c7c275ef74d999331b4a411754e38ba3ef4ec3b30c60dc1daa531e939c950c38115594dfcc3ca7eb47ce0262613dbf831fac93eabfa817ddefb9ebd298bbe6aa420f0125fcdd0dbece3fa5b72d2570d3baf5c6d1120bdaf5a33b2a6f871bb89eb6721e169f2e3fa9c6dd606dd2db63bcd208dfb6f040dc7fc135494a074eb8c2f3aa8e432514e8b8eedcdb09770a2c8eaf4422ca247d38b916a20946287b4209aca3c0ac603a62c64282cd2a8fdfa87c2f224c93fede96ada92c837d3c7cdc5518faf06b5f530286a3ebeea02148bc2b07289d8d769fae5c8f8284b995a7c8b09f47146f5caadcdf9c5a2ddad9b9d2cec8f61e55209d1d0704ba1f62d309bc944b034def5a2a405e6faaeacf0dea8e564e28166bda4be7210eb933918e4f6e5d1c9e3e3883944873254c8cb1af7fdd4dde57f076423e21aae327a0a6c6efde32660c1eeb8802916499ecac8e716c40097042ea1daffb2815ea65c8a82411d7988a30fc58da6a6c0fb203f421e708f118569707844ddd1f5d11717d437877c0369a6374aa7e7276848e77d4f1677d2a2368ecf76f05e055d14170de1dcb9c6d4113f5907c98250a954880aa49fd93d8ee5d816b06e02080324f1ba9fde9079642390beb90ba541df3cdb2574a553586a5af743135d4906f2747bda6335fcb382794ef50d761bc89383af3f62d21fcdf4b326198c7daf7a084cad31db8592c5895db102e98b0169d455500cb317ad0d17b2f0aecc765801d653bca1c96e7cac96be33dfe56d90cacebc821499736abac75aedd53036073dbad595ba678234fc189537170463508127e6ac16a131360f969b8201463507072dd2aac5eefd99d1e80b0d6f70e157e20c6de493c048f6f8ed50058d634016fba4178c59f342ffc84aec4bfd9a85f3f5040b0e685df63951ed15c021a5ff925609a7cf6b827dac83ac4cb3542ab57e9dfd54583f1207c089e8bd1be3e90a0798c3723a2ecf8d83d28d5d0b4e43acb29510d70c9945c54624a4478bf4c0bfdddac315f89a8d82272944ab82037f4485a5931c78566bbda8f25f456de9e51d29db284789f499193fbdd81c7fbfe66a9cbc036d022fb9a2a32393956c94256941fe170fb80ef97c48574d7764d0d3bdd1c420e71964ebd7698b50144fe66964810b20fee13fd39a859ff826338a54e5f53bdd7d1840ffc366723a0cbf0f2dedc6a4774d3f3917499c09f8a0fc45023e9ea3a37d8a8d8513afabe2fb1a0993c1965230f64059b606b0d5847364579c3b86b0990519504ad30d087cc794787794e826f25c0bbcddc6d7cf25ba460ef979bc9a764a34209f12096ea1d11b16e70068b750c7964333427be8e340ef9873b6d275803f16d0fc23e77687a7f28e6fda39447c737461bad1993ae4e10ac3a085093aef25662f0ce380ef6c3d3789ea8216c765fd3fc75939067cd2bb1294f17e49797910fda496d52b9d1b98e4054aaa594769ef3341fd84c22951cf959dcd9662904a3d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c0f6d5f11d075726cccd9b2f7f0bd376"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
