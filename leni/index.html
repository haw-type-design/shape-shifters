<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d92fe99fc7130b2f243da9cc24b959bf867f4c283f9fcc8ef025d05622641ffa72ce66423f03439da7da96f432cb159fbf632a172d58908fba11c2e27daaf6a01169f3a7770151bc84369aab807281e90165cd33470caaa7ab3f2a8348a9ca4e9d63c1e790ad26f3c84663eaff4f464b82b1bc3bf2fd50990d3c4c13ae2dc8c2058c5a6450b72f47d5d58b3db7920a859a8d288d8c3a371b849291c5dc3055187f870b1a6343f114172147e99a5dfebc2d5063f7f20b0e616fe081822514d17d54e60f9e8c29e5109bd2a5fca9c41d5f61763e04c7a857e673bf7b252442d7ff6d9d88c917b1636d061dfd2e0b2c66e83079912e54a78bdc7afdace64eadfce84dcad54b0bceecbff25ad4c0c2675d5c7bface258c3372dafafafe4bbaa28b4b61cae9c0101c6b0bb9cecd9d7f0b6b3987b4816c2fbf9711a0cc9ed110a1e34732e79f753de19b5420203f7836f49defa3b2c9d39f3402155b5f2c6529c17378a65971a78f8f336a0c00e10772a0daa7bfeabe996c4f2ec0cc28b75d0d45c10defdb4e4bb9a3228a58b8b835ea7f8a7c01fd4c90cddf33a1f2a86bfc530f52cb49d40e42cd476dc40cda0945d5f2d33e361c2ac1025eb4d0e8fd0e3ae250073fa93114b4fafa7674aab75532cc0c525d3a3c4ead48beefe247275b547236e96b7c1220d031e989a2fd3985dbe8b73038ba18e8378b6996b2f82c77ceb18aa9ec614c7a5fec21f7b6dc43d3eb72a52a9177199d00dd9c2d01f03bdffa602a09a95dee32e4ec4c47110a76afccd371eda8d36a6e93b211abe78e22a89228c7234db06f84b1fdf71492217434a883c26dbe5c5df3284f416442c1f5d606dbfb31ceaad8628c8aaac811dc7d078b2a378d7909cd2e896383ea32afc3e9ea595312d131f8ae7cca12dfd43279cd0200b8be9312678526f20ad8d47431399b729c525b464227f266bde0266cddff827abe8248f184db06d20d29284e986b548ec25e83767343f67fdb52ff9e17e1516e4ddcee7c1673630196e84824c81027b703948e81f3567d1f5978b89efdc868144395e8a844cd952673239ff542894d6999ba242bb1e3a5a374be706fe3f45f753cef170bba9a654f8dc11d3c9f40625022ceb6ffd02fc5cbedd67f5574125cb1f9da15e25ee819edc150523fa4d099ba068ba8e13f6ddbc6433cbead03cc8fae6f635488a905914601e8e2326b7b65e4b0d0bfaa2887c9aafffdfdabd28fb52c05b1069d61c41bcaa8cb63843ac818ff573379787c4bf8e46c3704daadcd2282439b5cafc53bdd26f1c8ef0f9c94a1e0c8918c716c4e56d0d7d4362c97523669fddb2d2dd4abfc21999975c2722f0866c601bf243831243297df5cd32073d39ee2b3fd129bec7d70123e96ca1f32d9b31e2f19dc71521e6fe09e1b9c3c6c41074bbfdbfc5b0a8600306fb888db26be627de7f671030ee76393b22e66b3a642453e62fc5a304d65c1fe29841ce39c8af906ef75eb91b0d41e1c83478052db72ae5a596f735317ab7d00d00c60ee59968d6e85b013987abc1f6bd652c6f64e4c6e9139f91853a903e95d53776db1fb6297905f59545a0cd6b194816476c57bfa1ff074ade8dd004ece0da6c0f1df90d69e2452c766c34eca2a04690e6c61d13a5c5501b6b9db068a7bad32f75198c80d231f73f45f8db09b97d7ab3083b55908761555aba3a93d2d4697c2e8923793cb7780a4e6b262b72d73310b7b8727bbfb2e9359ee8542bd9c35a3f69c66d754382e6208523408e373a7d212af8ed9e2a2aeea6179e734c10e24bb62ddc6f25bcd517c3c6d4a81c68b3e6c4bbbad8552d9db569bb7f3e13006f817694ecd87879d52f777c8d5e653f2add4c430c43bddeea1c849c26f2db0ad2206e97c801c683d4b8fa0e5cec3244e22a5d9d075ad8cac37158fb645745b7ae644cd69bcd12f867073306c820bd05744f85ca3731c8b061a339f843843640d969c60856d59ff8d0693b7291dd76e4509559816428864fdaa09aa18d2b85023c146e4f5c43e84819f547af473d05b3362f2c2f9a5d2aeeeddc9a831c8076cf690559d36cb10695e586769d8099588c94538e57485af8bb64b9e04f217f1d37768402cc1e836efefa29d49c4e073e403e5b789e16152e588a60081f5b181ccce7e0fc76651b21ec3dde825afc09538cbc82d1f4975299fccbc0f3a6261ef37fe2caf157fb8d4ac70d552290b46a423aa2929a0af358a7cdc57f79250dd3bcc640f13cc3037dd9df14ae5478967c5cbe80e6046d8a901672d9d596e7b26f05a9aec1da3452eb33ba33228ffa812c10f1eff54ec9951f85be894a73a70bde377969c5e7cbe639d72e779783019346b379d9e86f4d628ee9b9032d4b56e699051be3524d27059cdc7927063cf06443b28bc817f0432341a62c154b95e80e07877753e2c0f561f340053dc5da0f86270289f459e5ba59b5bd78b2c9d6972800d7528da2d171ba9b8111c16dc69fc6dfdfb4f623c6f8392079f338eecf6cb4a112327b98dd1b9ea275551810f8c98c4bdc7b2bc0f3995dc4ab90091a837d91d642f60543545a3f84934a33d01102bbd683f247dcefb0320ea1dbf68ea3b2fdba99e6f7862cb9c92f2b1cc001531725499d237bee5fc1c8a1b427e532698220139f3f80c300f01e80ca3d829dfd17149e40a24630770bebfd13b602f3fe19217d087ae0b288b707db113977804485889d369d36a5c1222e91ccd15d28d51d5a754d4fba9bd1a4fccd74df58de4b3e1e027443dfda131b88e8ad89316b173583d75390d389abb64309a31cb0a9e7758b3d159a07f75641be1a53923377a03aa3782ffbda5328b0616e3d5cf4afaf20e031d31cd362a21c6d17b43e2c5f3be58d7ff8f58e8a0cb27485d8c8b5d7347d411feff7b96478b9445c0160cc9b83ab4928587889c4fc0d72eeffe4fb39513570d16d7b32b2f346b0c0eef94dc85b03880688887f898a5ed701487e7575e6023c3dd9544509fd26b8f74dd8568186daba20ce845a70d51de134a66833879f7537a9f7baab4ffd5ddc7b77e9e65d7e981f502aa1cfb029d21fec024e38f6ce6ffc6d175494dcb8850b5e652feb745f47b5c46a45507bd647ca8fc8355fcdd318516267367c914a16582228ff370c6c9edc2328549ecf47bb73f492fb171cf5aa1ec8f21d19e28180d6ea78b485186d836f6fe85ee4a71cf5f4d58e045e8f05813012a73a9978aaf49097504d49a6e0c18df9d0c473c117f2f09e83fbd8b6344c2e74ec1942b552f272279e4c32220c9fb62e63d9d1c6d73739bebb56f536142a7c5749468e1f8aaaa10637bdd7d8e04cafd817ba08fa74a849fb6ab53ed16f90c6d43fbfedd8c1a7da39dc6b937b4adf54dc81439df228d6503904fb3790948041a91a05f2b1069a6c951ba04fd5031d25493f7c91301debd45ccc310e58a182a5ea4ef60ed5202f9038d15de431641b292838b75e9491107684f4716a4cd4e1a1b945103fc1822a5d5e028c19b52aa985f45a7047d2ff56dc620441f01eb706b7119fa943933e3f838f371d1e41c69cca23771c3dc97c2640e4077204164a30a3b187201d386686e14d67f3d274c263b9de4b7696d64dbbe7b0b1852fddd06b628369e8c9ffa8b1bb96109c71c003b98f7b34cfc65860d7f325c797a78f357e931a7703527642b2743a046d0197269ef79a57a523294610775c36e7aba89afd558ada1699ae97c3e56ce765b966cff3fc131893cf938ed2318da09313eef7f0b5dfce36eecc6b8d1279b3dcc657db444455fce089397dbe3f3ce9e71466d5f723ce5aac4742d9b9746b7b490947c3103f9aca871570af849224c15757dd37ae79a28e4a8ddd0d630603b48047b996b1fd4d5a161af5ee1afb72068f304284ca02c47500d4afe8bfdefa252b32d328ecc56484d39d672ddd978657cbcfb108de05487cd8ce205aacb8494786f70d3bbece5673a5c1a892a92c397f85f23de493632f2805316891967f88088591d22cc96d9e887338e524e3c57b584fedfbcdae3f599064a9777fd2de552c300bdbf2fea5f680bdcfd40d2ae21ca68c81d5663fa606352da6b45e22bc9d124d62b1c1dfa2479f1a380e3c5e855ad4f3d48ceaa0de0da16a1d968844a6c07f7e3599ab5cd2f4ef2df5fa9c6ad4451493e2392d8185c343cc5ad08669d839f0b001596d4a15a4a3082c76a51d1240218c8fa2d53ece0b819db921e6483a185b33d0f7b236858baf7fdfaefca62bf5b7d1e8cacf09984b37bacc90202a6df3566c0cb66aae15cf6189b95bdb5745f2993a4735495a2ce7929d5360a465cd854b6f7cf78d4e556964b7f2be31c973b15550e2ad0898c9aeab85580bcd963aa0b46f91c570599445321551d990fa9b99276a83b82426dcc0e262f4e69c02f0a4af117b503693f5080f4a2f8efb3aea9fbb3f73e27d1ea899eb84c7ba31975bd64b225ed2176071c907e915af4dad48aaf7ce64bfe09cf7a6f68223bdcb950bf2fb9d8fae82350b33b2fe2aefbc81f3d580c9cf22c1444e95bc76909bfb0c4732ab3347b12d89bca002805fe7068ee62c640697be61895c9d5548403e46b2e37a11befd0263d6717bb41f22fabd3174c612e98045d5bd780c704cbca4a3431f9614d07bcb8810e7a4b25753b2174df0468fb664b9a1f95ebd82c662c7bf77aadeb71ecf237d6237886521148db13dbe56325c5c88bc48ab342ed30193c9155ccce2d0204246b4e7c99ba5f2b7fa106c86c446bcf0412c98e945edce087dda7f3a4b5c30ac0edbd07a651d06593b699f863775a6f90e1d5b5af73b42667960ebbc03381288086f77e3a1921dd47ddb0f7ba3b751677253518e50db4905ce786f7144a90cab208e04ab47eeb581602becece46331f4260f385568edd33217d15004c6c95f91b7c3641c3a1ca5c25f4d2335f966782920b68f51d3f6c6b2a22b0aac29ba85361ca286d6f11bee63840dad5bca1170699abd00e9fb2655f2610d98b7b3d2e415a729346ba44a6d669076c04df9a10bdb805bc9ef9a28e8e8d231583b2563f13943e779d9321d2678c30c1b10e162597b5ec1533fac0b3ca689daabcf733b511135c0799518d4e8d7252a198f97905dd799ec08c553b958d898a810556ff59d183eb6e310e02059ecc214ea512541e0c4c320233b7a219286c9388451f2b2be212c1505904afda124af651aa88129efe2cc9f91a021f3b87924b477432736cfa865a621eea551a41a8dfaaaa9ac8c5c791b85a88c26506882c8e32d095fb3b51f39eeb0424608d7661026a46f56ecbaf5a7009f76b298b0813c484ccdc55716d58d3d6c519ccb5baad96bf5906426ae35bd752e7f9b40fad1e0f67f09bd54f31b319b06ebfe64ae08e702ef8691a0dea97f19c068aa3b2e41c6e9b0f7ab6ca7dc272877946b4f764351f30d676a1b954634784403cb259d2955b92fab94168a322327859ca43896993f64b2aac22d7b3d93af3d5b3f51dd03c4b6c04bacd37cf8b56f31c6c39443aaf8e9075969873cdf66b86be5147432a8412987176d67046187f4d294c782f34a763682fa56b3fdf3ca2af3d8785acafc81a6a378d21fdf3273407e0d14707ca6ab4d167b716d6a1339a84b7fd3678854e4f0239b6ee4cd3dcb34a1a67f90088dbf64db500b8992eebb29ed56ed8427687744c005eafdd07e2ef8f1231c766978f8582330b2d5c3fee3d1bf69caa5a1756f96712180e99157806699a9742e9c103c3a53d9e31cdf4d0a23b2cf504da11efc454eaea0b2556871fefd467ceaaa48a66dc6c18e2a492ed78788dc6b91c15449d47975a66c9a7746bdebf137d0cac0b6d29189cfbf0c5bbf5538bad8b0441fb9a667931ecd15c9ef4eac4d98ca6dda8eb10063511233d4314c04997b9fa9097addf9fd7b3f3ea1cbad35d443b9d5b141629de023b2ff96042b07907961f0ac4d69ba75fa63e2509fc8e1c234e6734bfdcff090de9dac367b1cc1333ea53635fff4d5ee1ca9099f481a99a4ba67494dbe1eac9a8c45f02bde7496800229934367a7bd96634e852bc4afeb3248c0ae1241ac953bc56a3ca677458caf449e3a8afa9be953d305fffcc752b4d7820a88fc7577bce46984e24f79720935e2f311479ebf33028d9a59d676354d5777a64e747c10974d7bcf0888fe53199b7a60d287251534d61f75781a04c4c99ccd0c08430744d2177d2547a9531840ba4a54ccc261841857399c64a3f4fb15255fe0ad57b4f262a8b26630798b16e099ba4ef0784edcaeb85b9a7a7ed0c8a2e0ff09a02443a644953661978dbcc942cc8ca70682133b8b955f47c4d9df013665c0b8164689ebb608428ac87ab03dacb34141d943cf73686edae6b7198d2ffa2f93cf3f94a8cdee0434d40233b0d47468014a482b12ec311faf7976385dc4a22ab222a02c44d5132e81dc75abe8b10651e2735d5b24f01a8f3b6e94b174a2b7b80d8878044c78808308d9662b4dec230893bfee1c859e5b1da31606694f8b525a40f49c36c70fa3159baf7aa7f52455a4b4deac559cd3f70899c9c255298d39ea79cd3f46e6a0dcc3eb0cccd241ed9500c8dc6849717b7c37f6dfbf5ce116ee62278f729867fe25a830e688cc6ff2e53611d82b7be02ab35e873791bc697377142a35e29d7605a43ab14da01bb2331abf65ca5079323c8a5cd1b75b488a9aa76478efde7cb4197c711b71466d30e489a2033216253acc4a9b75c9bc777ca451f4cdb67611b39661c31c39df96648194aeee90866fa4b5fa2df6392bfe6b5ba0690278838d616c2d7a54a746c73ee190c398d97dce39addf7863bb30e24d493405d21fabaa2a67351dc8b12a724f8e283bf8c5c4615f377b6ef41c396aad572d180d11f8f3cab1c244770c5e51408aad6e7fd6318f5121b28b617971e67f53309cfc91448537c03b849060449933525ea4a3e70792f4d97ddde2c379643967a067bd7294939e4e0b17aefa679b8eeaf98f150ea1fecf5510a6d67978ded9470fc35718a8739d3bf5bd6c105ffd97cffb96047dd5b6ee6dff77c4af5b90df16fb535ab11984f89e7d5dbc747c473820adc63fdf0a3600702f5f070b3c584945590e7574d4841a93e3964cd6d745180f8e6c67382e37f407248ea05573be6679d37acdb1babd82a9fd0c035e33a0b99ad5ba18714c75cfba90f12831a94edf346a3cad560867cc5ab6fdce47f3cf98ca2be77e7f7c2e543bd1be2cbc8ba4939eee5f961c889cc8fd430089fb69223d2a01b6193f6bb8757ca18b71de64daf1dc366ac8889abc508399e92f5083f5b5ba8f76ee1cec52194acc00a7275495471b3c499b274cffbde1ad1047aeb1246a96cadbc4123510374e749906eccd5ca8458d1a0286f8717d99e5eb48d11bc5127df66e03b27f96e7aac57a81d666e5fa66f8391da4b24cbb55a5f8af7dfc9b1e29d446823c359f2b04702934ecbb79cbb153e6b77d0bf05ebaaa098785c92601ccd248ebe1ff2fd8c81c5d4299e54cd2e69f82baa451ac4714fec3dc7d9c2b1560e258f9008dccecec79b34d4d531d871c6ff442fe96fae5b1f9edd8854555d7fa504176d1ee9401522bf9a7ce301eff8d94fec0c07b9899ea08ec54b7cdf812c08dc10b258d29a49bbb205e8894e95ba4683bcf46421d66045d66dafc5cd969b27d5418e6062e43cd3d3e5551fc6b30e4be0b0c2fbc028332c96961f6e06719a03337e7f5bebe5463b29ac35d7442cedc6bba54704570832e82bc7c235a5a3a8210896e6c7d2b2c3dab4058d579eb0477a6b7df8672a8aac8b257d559197f052d277465fa0f7dd48df39e46dc8782649f82954a59acbad229fb4a7b4bc95ec71c82671a0b2f835f0361c34a8b63f97225878c9687465274e33ad6497872c7874f6e52bdcad28fcab131fcf8a0cad2bda4857a87d5a31ecc0a8bd92eb063d7534ea59fda538ee77ddc48c934efeb94d34dcb634086797433f35dc4e8cfef38b4a5fafea00593443352a0efa6f2ba56bf82dfa5e757ce497d35f06e39bebe6589f608c4226759b33e7b6fe39b281a77f182bde55de7459906596dddf0a88ad83242332852c1cf88baae6dc156f0e3adbd5a9be2c2f12a3f81ff9050e459cdb4c3988a1efdcb0568ac9b59d44e51229cc6f135b6481c543feff9a82e642ae0df45d6568b1ecc62ee9ecaf0a33c8358ddabb9b01183df5e63832602d6ffa0d05d95eb832e247fcc411993c8607db13f3d4bc9f06a08099d883a180dec846344780181fda2c27128149a7196840a23143f8ad805707a7da2aef6781439d26e67b2bcfc6026902afba96072118204300db700ec3162df00f655d110216d521044a8d7fbe55407bc87a60013b119386c0e9a91ef92ef181e99a8679eecfe15d67c7a4238cc47b81ef27aa354184228c381208c7d120eb03cfb1d5da70107de1b8198e1a959963679bb2325b7cf6a1b3ba374b21a2e228f982a21f95adfeee000b71cd42fdb4ce582a327085f5bc02094f52fe7ae23c53ac5460036daae087449d87056994f606e89fcb66dd95ec2d6edcf7893012f02b2999d28a19bd520a62c7911bb2c90e340b89f45599bb0e99188a75eb2d774c38faaaac59029c65db527994bf043d965e7f27e6979a53bf0498e4d137b325c9da51e0552dba359a3f43872c5e5b445dc18e189dba0e9ecd437639757e7cb7fe363b03e23c3bd2baa59e4899c846c26458f15dfabb1e32f0ba286837bdcdf402b2dff5e0536ab12619682ddf1463e5d5aa4368ab269a33187261c142a358e1a972fc385ccd7010cb19e123ebf59fa9c76904f8fd5465a4ed4addb5dc796547ce4cc202b780ae6c0f79b2479f6c0cc653ae7e747f19416f78fb5306e033b068f8629a36ef833a40f693a60b3d445fb4474762d05821367ff161dd52d6e9ac1a84ad9a789ea10c2e620fe14bf8cd2391e7492f5d61fec365cce688fa5dda4c8f1d4ca0830523c026b8d2ecc2e8c1a94fba587829b13fefd50d15f3b26a6cf35cd0e63a0cb5c6a94ad098c5858c35421b506bb34d4996c8817e31830678a8285ca80ab5d81404b1f3eb2fb0b1435b9bf44727b743f87ca64de946dde61e1cc6e9e1613d1d56711b313e53548c65840469d7eec4d68ce0c3ac52b3b7c982a94a495636150c9d4f9b598dfcdab1d562a931c95475a240500d9a4c2e3143c790159179ca35e3599d7ee9e48bf25aa9d7ec262a686a22f8651c4dcaac8821b5d55466a2fd384c89525df5773638eed56d97b505ed4614768e75d6bef274d8d2552ea81884fddeb91657971c6f318de8cb4a24f6dabb37bcda7a730c03faec7613486347924e749591f3188553146bfe3bbff2e0e1b6f7f33aef92472d873f9c3720feae3b849debd1ba85a19c51f7742afa1eed5cb1166f02777ded8509edefe9fd5ccc8291de3ec53fdbc5f9124d5a743b6b709589035e132efbce4c4a0ce4645419c567c6eff275d548d51a8e346847788c77f5087b899ce98d9dd70084e4f8e671505f2ac585163432e09a845cc8e7f8ee95e9cdf42125a693eeaeacdfefe889103435329e09dad7e50554e5e6529957d1604a5b26d3a4ba3c67486ac5f20956f70cc63c3ccf530c8e7b3caca590afe7bc8d683038de380b27d68c680eb8c2b8b307f0e06cd750eb90f52b1c76c16c7da0ba561146667cbf4105c6b91f4375f1d5803bf4061fb1a13e81745a53051944862680fdca00cd44a6da927973843221b9fb22281bb6d8c146665258e725508e7e9d3264dba1198dcb3edcd4d7014ab41d257fc099bdf7e79a51d0e195c784e585645b8a9b9a3115c64f8be7328b30e5514a7add648eeb36b46e082a5ff0d7c459673f9e00be54dae2e499d2ae1d0a1e0a2efc36a5dff858305bab98a99a951d4b14c82356cae9077b9bd13b6b14755d175e763544d90990df877f885170059e5f8d607f5d35c2f711c899d7df5c77848579975753bf44386842a1dff3d6eac76be2258fc1c5630912fdab9396136da281dec075f26fd5175432b7c0be0c23402eed1e27bcd70951928a520a4fd5049583adecdb42a93e1bd2fa495ce860f139d26aa04bd0230f8163df2157a7c4e0e45ff1840b7093c1df6be44fffc4d081ed9d74555f3f6513174ac74e3d2695c5cedbd11bb020b95e7a788df3777fd174174ad9118c2ec8712046cce347fd35c458beb876046b010f9502fa078ee2a834f8af82eb41cfdafbdb59abe199500f8d713ab17c09a0ce5f60092ab89661bc4eed9588ce5174f900e9f6a6dc739ee6cd0a437ba774ac08cb9771fde62a960bf9d2d2faa70a90904f1a15332104a4d6b7e038f9d6559b22c56eb67da48e557339c450d8b251dae2181b875e10766d7a52f823305f079f5192d99aa7f1054b0c8fda31dfd85e0e6de6039e9df377b8f0b2ae1a23432d7fa197dfdba4dfe5b11c97d95bd989c59ce14be9c6a7c30634be461916443df6b47a574c7eecc039e8d17e3ab70f595e89e98f26f1c59b4be23309900a0c8ff6dfb37eb393066e468ebb38890cd20f1554d94796c546f101a24f12149c7dcce211159e41d9ba0562675bdd1d5e7c44daeb2edec9a7299330ff76dac0f597a0fafde457935976955b0a81dbea1702a0d0a9c464c7f2142ae1f694775e4e75030176cc0c36e2a3e9047a359dbdf08f0f4c433d5a49186731bcd74705155b16a0375c88a1150c9d70cfab74cb6d7769fe9ea4eec90c8342f1fbcffbcaa66be34db2266712ed5def8856ab375a354baadd0115230e1d5ddba52adfcb461c79ecbae729277c8b0f6025f04adc3ef5dc900e285e365e3b448b9c0fa332d4236929560e001669ace183aaa0e94a43d90590e061f70ad4cd05dcebfb16f49d41b8720a857f6de9a617dac450a2b1f1e767e8e0d1587f11a0377c459b6b11df67738c57aeec4e155ecad301fc1ba75ea523a33098f19210156c8d08717011af01054bb91805322a743b8697e16e24c8cd8508095764018c91a76001a8f437da89f3843dd875b6d6ce122a9730b383fccd79180b06e323200624d8b15e24057f2b1904f2bb08503ada7adfe46c51a8395b249d4fbfe80dff0906bfa1b47136bdcc7ddb6be0b993fc3481ee65ca30aeb8f83e8dfbb907f327bdac46d10df0f11b212951e7d95cf7c07076e7dd8de3795465179d2295a9d2613dd9c2b6b32f6088e8942c9731606ed9348f251a732db5f7e6e21d3428e65ac85b72ea46f33470d125a740c6b227489f7ad16b6617855715e9e0ccfa85001a874dbe79ef1409d30ac47af55c1c99a2fe1a4d3ce26ca5af243c80d58c4aa98ed0ccfa0b5f9f671ecb11a9db3f366c33e44e36e9ab6bb31c0c4a2a49f6a972254c62d58413e3b356109e0f1ea1de804c916c2907e7653add80efe6b9cf4e162972ba4e897b937d2747d80a39c186afd0d1d116473e1f70622c58db1300f89718c89e0e38a03e84659eae8888115c3b68313a0f3d38bdb3d46f97e66117553324cf032bdad329d81c82715382e9ddebe3cf46fd054df5c39daa6994ee3e4b6afbfa3ae5302575463ff467135ab2c93d18c31dab55a996b8bf58cb98464c5ea0c08e04a935eaaeb3ae2c1b68f2a9d7ace53efad26ce4c73485874fec60c44c007bed3d80ae558a71f059659f9326fca68e3772782d6f0c5f7eb43e8794177d7fe27912176c232f8a771428b3a6ed2236e5cdd97b93fd3e0b2179091c9ddba08a12c3aeff1cac415cd334869cf6ff36cc3f04fc2f5c77693fea0949f2a260cc2ce3b6f99b233e086c27b46982d7505b1fa4cdbaf934161820fc31be2d266864a9155a6a6f23016c2bfa4070fdc62320d19a7d848046dc118e10af9972dc33cc9b7ee14f0bc368bfbf6a6120c4d35389d756a0e6315c30163dc0964c9b4017f96f27b01b27a8d51377e2f1167be82489aacb314faceeb63e2f17a497ddab1566d62bbfa6f4496fc56ede7d8138e442999c4fd42d3c6362abda64424c4d95f96738f40379df36b0d8b7fa5d0fc5ba1e181f78f78a8145128e58b7eb36c2b28bf902b36e0c428eae91c5d6499505b8b17088e6549aa215dd6892855f54aa2aefc4e15465b68319f6e36a3a6fe8b69ef785b6ba2e8602d409abf50e6667b7887049d41ff2c68136d04ea0d6b920c7b03661f0f2c539928986f299fb2d61418ae564bc0d604cb1aef17e73c659d2198578fb607e1b2e9dfc73cbacfc63fbb8bb66ec502e1909df649b5d582088a39af3dbf41a5167d71ea6119007a27e1ee56488af2ab7030112625592ea82aeb36ccc2e73dbed303b87509b9b4ce7dc65716401f5c1639df251c21790167a229f1ec2a1e02cb477daf5f74b85cf25bd7324675d23cf7da52e0c5bfc4b3bfa46a7a9d5287ed070a238bbcc79fb064fdec1444151517da0dc6256698bf6e1b57d4306cad5b810a424e11a5f4c1777118b6b1e7f973137b15e84b1b088d541af11f05bd1774a72b2f0887288a342ab31dbc02fabd81ef9df15597c74ec8773c311786cf1bbecf9fe11a2f495c6cf4ebe10a484d978fc78afe179853d66ed657fdc9ed9f5e3cb25f2a59e3f4cf7cb3ceb60841f833457241e856440140407137f78110cbdb4e0795d493d3759066ef52bcf1785a656242525edc2b3e15e6ce2a6d8bff9fa450e201afa22865b0da8ab605dcc88","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"a613852f125b854de8a2b3adf9c06c19"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
