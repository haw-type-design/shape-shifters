<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5b02ad9426f3d6f705210184c3cb2104c2226296b8808849752ab9d66eeed397a0462f6255823aba7c9649cea855f9525241d25e497c02987bd54d93841fd286750afe34d8af3a9c335d541507b587f27fefcef18af7ae42641cd99e2ddc53257b4375edf7a3f22313f81c1e788d5ba27eb20c8e6a76313eb27af7d641ced0a3ac1e7617856e73cbb46bb4af6647f5a41284f0fcce2094730bc7c99ad49b07b21072b5b0a27cae74d15b4cc52ca2d26133f58395341837cfcfadc729c27a11b75d12b9626409046bb54bd9b0f01da59bba04b4a141260a6f9824b22a4c12e9925926ceae7ab0c5662e349e1efbb2226a48ebdfe58859573ab8cd757e8547f7504d4b55de7d52f08738d404920488ade4e092b6288732ca5c7df1d737574f2e6cf1068af87f7969bdfc7cd5cd0008cdf31e945c0fc65b45157cb222671c56608366c3108b89549df89c819bc6c0e29daa62e1d01b93d395be4a3bedd780c51e4316c63858de24cca70a1dc6a061f8470b8cc77e10a793e1d05b7962d7bc586b2eca788a423627a98c954988f0fb36c66aa22fb049e77a4fde7dc89d8615bcca0896a5fe3cdf633ae64ee201d9a1c378354e413fd927258d373f20ad24da3a4dd75381d873f842011d13ff2db3cbef6fcb9b6860ad61cf9411349618369829010dc5dea90600b59f6eaf147cbefe196ea24febd4f28270879cd77eb9a66bf428b8f30dbfa0389d1eaf416c04a508648df43488034f808f0140409c42e02fa6b841914b6d899345843ccb59c66e65f4083c99a03ab268fabe5029b9daa706ef0f86a7cd84fe331da7a48938d630d6fe89c0eb48bc5fb170c9f3966a15e2aa4c58f659406adf97943faa0ae215bbbd941853ccf0e6e1c2fae74527268b1a4fa52db2af35c649ba55794e420cc115b149031476cd159922bfe69b47984063de17b0652790fa5965fe6cf8f81a646bed2888aafb2871595bf9e41765f189c39e6580c9405ef96f2bbcc757548676da96dc374cbe0f3b6b811194a8beff907a209ed8477ddd91f72c4e61acd595694e425be2203a4a8e56973e0273397fc7373f6be393cfa0abd045d9b870310cad0a86596851478b21651c94b8b5e0adabd681b267a3549cf561e84e5a2b7d6246b57ff1e5998bf5483403833dbab38bc45dd588c531375ae886f56b0fcd51e49bf02110cbd40b7470e2bbf9899d63199815453ba0618beefd92bbed09a11b5d17ffc992f6e0d8aec105060566f2fb7bf04657e89edf5204093636d1296b5a0a314a233d379c6603695acb51ce280d74ffd9a750b6a531fe0ea7ff51a0e0894af7deb3ee1626ea7506675b9f71ffd315321d2e655755284e249de798509e571dcba4e686859d6b413912c9f0fe04ab2157e334bbf9633342464840539e9ef6e56e13697150a20e7b869a219e17053cc86769743ac1799d4db5866c8f31d7d9f74a1a2c1486bfc7c0646f0d9495300baa8034e2ac517933b8925d28b36953294b5efd17b9888f3029945a0dec894121cee289ab61f6a7d7c18c5696e150f7f1ad23d3d8637883d01dd6fe663499ea51011559e753cc8bcc5527614f162e3eb839fa0d3591ef7cc1549083f3b6f72eef688be2fa31fa6a5b62a4ed27cccfac67bdf1ecaccd66e469416110b8d2bd6561bc38a283b073c30e86a3b6e6829f5c74d4fac9d00583866754e7a54c402923bc35d246b6b06a238349ce52b762312fd20839a38403bacffcabdde562ea621d148d8802c84aed49f63a833f30f434ac27276f0d352d3e116d241e58471474ef805f70ec7ad43d71ef969d01e195b165d308ab0d52b746937dffc533a3d1d9eac1d48bf6a21948dc9a2ecd4e34d79ef9e83b40944fc831eabeb54a0bf81294137242be2f91a1e49b97acd1493a9cae5baa25a010bc0e3b5ca336c28be644ecf1abde2df1d42bee139a42f9327fd63a2c698a6067c3eafe58a2689c582a9b8d8c3515133104081ab310c801c8f816738d5cd2031d6db9e85498fbdc355364079a302744e2f1041e3c287c1dcec7b0db56edd173c8f2dc00370060355c6fac179a580561b2eab3c7473ec62b02735d81f8f927f57541fcc73e2a9cbf00c886e21c4ce189d176cc266b4ea0f289d17ad69135db03bae67cc8d11ddfbd49a0e70cc7b2d58be6576ff292f75d088f2fe8156bb54c60a6c84d0f73a0046cd069c08c64a85797914f34381e699b6fd7a3ccac466d7b47ee23b1591f794f5d9aa951d531cf91a19c41f70c2fbb93d60fa46858ab88df0de7e14d85b2c1271e10875d8a47f46ca17bc1365f00e8a16d1be069576eeeddb747b070891ca5da1b31a510f1c592c793bfc5410be69ebba09f529342cd44db0d40a3100f469e2bdabf1c02923c90f8ae3cd5c1b6209ae6263c076eea573b69be8ab80b59f1bc94a9c537206821c4bc8f3f16647c1fea811c5a64d706d092605fc834002034098f0ec484a1d7ba118e0954065d841eeac12947774f48f4d7b0495a3268648b3d177e18a3f3062e4add166b7a3c7d76bc5e8edbee4d7a1061a3d16d203aa95e9318fab7cfe70f636cb13f162384fa2c747033983880220a431fe80e90b26fcc7ec79657b894da9b241ba1a67511463427c8b8fce868af6df679a9c3a8d47173a004631bd06d2edf877b9195cac283847ff8defbff27090dad62c85b3380d330f273a3a28b99b3667862b564aac0c88f9e0b061d9244968cf45c690247f11a023d755591229a0881d380dbd87b053c39ee64ec58f1dca034083971ee23fa5f5877f06c9d42dd50ac8a1ea90837c6994e95e329caf50fc0be7f13fced92fe7610c2db9d111344e438ed802159f5cdb5e0ccb4943b9da9a38ece4ae296d3df0961eb87adf696370bc38079bb0eeee3a2fbd17561ba8b49da901b21fc6ec763b39ecacf34927c24a1629e86d96589f6e11d2ab422e2e8f2061b195d9199f1cfae90aff81445d4c990dac09e624ec217aa1536917b62170cd862374ef757fa2c037c030e11946a5f075fe3976ada3843478aee9743ce3a8a7afd95df97348228df6acbac67b6663b4c64f5898d0ed3d322b5ea50f98f8b8c9b81b7295b22f97ba0d8e934c51d423304956443bb35cbff0d40f9272960fa6d4b1bd2f10d7f64aa86ddc285e6910b8bc125f154ee1b444b5cee927a82477aeb91912f52667e1631480931e0118d231d6ff87d90b76fa3e39c09eb9b8fe5a35fb66e9b69fb03af036611b23ea51a6c7d8add1c00af80ce3f5ed9164f9a7ee399434bcb019af9253c59484545eae5ab1507da72f0f65ab110ce71af3149c2bf6027eb93818ec28db36d31dca6f5dc8b86c3d588164d4d0b64b213a10f02a9417553dc323ca7ec4427b0a829c05d814806b087e1753ae214ca7e0a38d7d2e47dd96a6dc9021773d61cb0fdbe68d0b8f64976101ab56a747898d02005347c298b18a1677ff18314bb7d4eef67d26aa74c447545801ff2b4961952951d2d09238f421ca920872fd41b713e0edf57a505e4f7bdfffb9522c592c4d5d39606857c4170672c0346c2676887b080d8b438f210ba83a10db25da9a9f8c857b1d3baeafc5cf56732063cb57cc1e697660d051399288c9d0f37832c1d059544ebf7fb5b5eaa74b97bc877fd193acce48394d2a10a51101a7cabff8ec850969221b00f11ac393a3e06a2ac9ae88a5efef434dc31c44109491662d3c40d360eae09168a55daeb9c26b1cf06eca5cad3e7517c716c25c720513a914ee9d0f0088057fb0a6d925c860609a800d9ec83e5c9a1e16645dd4367f4e705fef2364c33caaff95cf25c9363fe4aadbafc910909ce49449440cd0730eb8bb99992021c4b596ca1ca4ecaf57f2fdd35f81dd0b18b9733dab6799a9ff09e57575d3749557c3f8bfd001d1ce2efacc02e4ddd977d80cf4bf5e94d28a57ad88ea42d3b31d4017c1cb920a2f26c8518cb1bbcb601acd1c0d1b011d406c29b0a75326b43a5ac543bc6deddca82d15c7ffe251ffad8060f4adcfd85eecd5c102666c0caa6d0f13328c166c2a2014e81e62a76030da1a23f98dcd540eb1e095e71384fb03ae2f5acf2b7ae24056e87988f1c9aa7ea095eddf9836adfd1492d2729a42818f1a182bf314e8b5f46df25d52a4e4c64f8012d38db1c3ce809517da07559fa97a0452911b8717f1de4c09c008711895b3e60c0874e6f951b5ba040786246225242bcd9c030fbd4f61e7569c1343792b0ce835b4ad1a45b0eafe73421af5782e8221b3cc688c7b648c27bc8c2c481982b483f32a48c3a8ba6a4256eccdae6a46e00debdebc7da47b5d0f0ec775773fef52304d185b7e1a95f52d0674290fd2b232d8a02153c8a7ed9d30683ca4edae72ebd13c55467d0834d415986b5bc65ae7d28c3cb5cc35721f7d71e772395db44c81cdf067b9b7dcb9aa8ac9fa1c9c7bd4d69cf80820c5855fa0b2472c9786f1c7ee2503bd0a0a7df1093bc4b2d66a2cbd7de6b004646669cad3c06cbfe718478b3882e474f203d43e0250356ed9073d35ae5798457658cc1d1d200cdb7f85ca29062de0885db195f73e095c81d0ed15bf1cbde53de32353319fcf45fce4f184389dbcc5955e28701a59cedd9283880d981275d6b6675ade25fae33766055bbb3f18c162069e793f5ef63ee2b5b8129236f83e3f9181ae4c0366ad47ebda8682cc924cfd076cb535e0c52e7d1f84f5fb3d0f4f02ee7e901573d04ffe25b6d2fc53c0ef7b8600e5b4192ca24381ba2d5898a90031dd7f10bf4321cebf5683c399a57fde59388954102d67746b4d53984c547a9d45a5c4755cce9bf25f47074e484c198facbcb2508bd9b7bc56ef521560cdf957c13960d22fc6687a9ca36ef70405dd9d3a2dc47f1521c3234cfe2f8564e09bc19f4264a5b13d760d124b68939f27492c71fcb4fefeb49a81c4989e17fde58dc32750a3c0a59939b4ab878c5c0e3139b0c18336de051d8ed052f0065041af7147ab0aee785d7721ec065760c15b2524036cfd51a687dce5422508c82cdb4b58e0071c44b7006e9152d335ef2a79e47a1bcee2c7c24acc9648351173640b106e0f047793f42c351158e2ffb1553e3c20e85c658049f1a622fecaa3fbb08711bc91401b8e8bb9e55cae6cc65d010339799deae83ee5d48d593bf550ad9a44f33b9809488c55a8b208486274e2f193bc6ef44252cc4f02f03b43879b401298d59186e2b67a1656616c3b10db05c0062ef7f9fe4085e2df3703a3c4dd4d4a0444877938db4df509001b8fda19b1937098dae0819f591d40288cece3df3fb476a5ffa1d46fa0c89a1e00c39bb030e656538fa084d269fd26926e0519e7a2ec712e5a49d34dee37ce2e9bc33fb403980cb2939f2d8485ffd1090f32a237ece0bc4706e7a3a8835268e92e1fc1f96fee2ceb30739626179fefae8d8e699d9ff233a3b8b7e04cea7e923bdffaae16b3ca118093ea211999c01f5847ce2d08d77623f1a5fc0fe0d96a823796a6c734e11a2572976f21f3fc93dce1e8d0cb9c5193e1ac7aff4731397c613d888c1685073be591c6c0c0885f48423c98ded3cdac2554435883aa809d4f9cfcab2038c6d3c85b1fd9810a84ca5e08fdc4b1e1772712f2aff74d2be698ce86fc17755b0dba014e5b32cad7000c0fe058e16d430d9e86a1ed1aca9b7013c1de8ac3db362bfbff7567e2889a6116a1b7bbab2b1fea012a4f73234693957429c28a4f41d19e1c65f04af56ae8cd35a52c3efc2a3da977a282d139f1853b006ad7a76fbbdedcd55fbdee121a199f20fc8bf8c4ac1ad7390e8677b60c7cb284416b72140b45a65d48cdafe8c22235e32a0ab08421bd65c968cad2dec47699d858cea7ef62f6216023541c3827b25a014c2f4b4b3c44958a7fddd478c3f484e11a18e849835a7a2d0ca8085c23d0d761b4074faca3b6e7794cc8ea0ca75028e576840ea2044aa2c9504e801377a98f94b68a9c4b32cc97bca8d7c843caef768ecc6c5c1d45972d1970ae5fd3cb11c0b9048ce0f5a94cf54d928bc3a221a09e5e81fdec840b609416d15b7f3045da56fa373a839361dc0140f30c3b5529081d4f5eff2469aae0fe8f88f8062d088829139051dfdb67aa94918dfbc6c874877ad89c0ec3247b1050499bbe6b98f5863c6de96ea4843d06573ed7599f07e9686dc79129290d5fde578e7cbc5d9e326f145d0b90c94d5097abbecc30714b66b8a5cba6a1edb13c6281322c38e74865b0acf91aeffa9590bbbf25d48d64f41d2ef24301fb4fdda503a1d188582b8fb2130c83b612eedbd8372c6de8ea154f82a7fd075d04a27c9269e26cd635ec7e0b1dc72b945f17467191b23f7696af5eb1b374e4b743c5e8e67658175783f907f2479218e63b9f4c48f578a744e55df5709f9f1d0ba2e2181e045ce949ee76483b6eee2ba87dcb39d7f8fd0a7ca277ce26ece2618c61d0172affc143aecbdea4d2a55b49ae9e6fa2c78d06c27eb39b53d725705163db49af256eef4851f9c8ed69a24f16824b38b8cdd5fe81955ea81746d889300eedd6bcc3c7a7dad580bc228dff6a513754b65ef99d9d27afe08f75d456655ff1d8ffa3016a127702a6da8880acaa3b41b89fcd1b6695da3bed149197e8f3eadc495922616846d1b811237178b48beec1c263798cdbc993e1977a1cfa608be2c07d2a67f1295192b3e10e8dcf78b7041afbd89ba4a7838188c32a7300d63c720c54cd546c61f399965539bc3c50f23ee8f2b0ec0b9efa88c6f68b0f349a8403e25796f5c88632643261c593012ead5f36c5b559c98d93681922f11cf3f2ffceba245c2ff36862308eb815aed2bfab0b4ddb0a2cbfa0ffa4ba762a5d416869fbaac35a2271379f941ab1f9cb87f847ce82a4ea06e75281494e29138e95e7075ac8f8ec8388eaffffc13f513ff8f8a1f1d905e7d5331f96149b9486f4e60b9304edc5a80d72c06ae977a84b828edd48cd7c724acb6b574065a31caae780b11602f61085faae99bf09b1e6d44a01575d52a814f21417db281d13b5b067d0b95e1c20963d56ed39ac3e45bc4e9afa85e56bc6ac4cefe28fef61e6c62848132ad7ba947abe668d4256d012b8786408470df7f16807e72a49881825279af833e8e12332ebbabc750787a615b68163d26695be0f0c6ab865183f1a7fdb0116baf5c6011f6d40b02a96b0963e9801a912600a56eab23f8304f8d641d5391dc2389f9466a412ac5248d9ed6fd7b3d37f9100423d48ade426b4260693d96c192cabf201391b104cf55ca2daaada1f63c392d0f9436470d4485ad73d0513fc18ff63f3b16f773c26971dc407493d9fb7e7742f629755ec8820f8f2dfda15cb2a720176aff560f5510e4f6bc6099341cf2767e5462b5bd1fb546103c4d6a3961a63654599ad159e333c643df574576eb275be1e377517d4eeb89ba514b9b68e56d693da6c1bf0eb4b52158d549e7331a62f4d2cd9ab8739567cb4623b5e7ea3ba65edb96566b8e065ce12436b9b62db5eb9bc401e09ffecbadea844c7f3344d1ff7b5fadc95bfc5f7269f138ad04c68b4b37040fdd5ead180d3bd2a13216a8272f66e9c771e97ded1611baadd330c8fbcd969966971de309f80704d7c05e232b2b0231d9cd7d91e49824f2d939c06fecc8be6f831149ad906118f85a394347a3361869bb181b456743adbb15c8d61d4c61b31c491a6352fbd135e529e7e2f4798227cc4dc914303c3f33b589c27422746e2b79e157c1dfe7cfc0d237ea5a8bed1a31db972d9114be3150b1ad2f980346cd959efd921fd2553c7371b588ca7622293d90a64c80c37e4b1a1da456d70bf7572487cbc9feae418c8dcf2725b49d856c1f0924e5e20bce1f4719da4f159d527caf1db8594e14dbb41f195820ce935b28f7abe331237998207768688d3c3cc55de65fe461b8fa7541fb405c028a04bb7379faeffdf4d3c71306c40d4623fbf86b5ba432547c3bb29be50c88c6566f17b641ca013e3649cb64f270e9b65d52c95485e0bfc14827b04f3709692b924117ae7d35c3fad1c81e7908fd441355c2f0fb561295dee59a3443734bf54688af84dc85d5d5bcad5e9c685c10e103bd0473626f1d4843baec0b1e1047ea804bc6d97ee1ea34510d2038ded773dd9fba29d5ce468d18930142acb9b5229b35279934791587a14f7cd4628734f61b3b9369b2f5e4601692ed1dfcbf617e647f38801f9f2d913f4bc2ce1a27f06d2a966474daeebc59cf5c22f85c407932145f70f827b760f7690a1423ae43285bc60bf4fcb5d31600bf1c68938fd487779515ea112fa825aa9c5b0e935e462f18992871c29e20e94da632130bcd6e9ff767e260c9959e5db826a1804ce504b37ead303753d5f9cf3b1b9a576710aee1b96baae1577ffafa17b5dace0c19fbc8eeca6f92de188bf45e1e8f74b32820c6b9bf575f834147a9cbc0528cfa85bdea2593dcbaac320f1b6f207af37f536de35c7dcc8163b046a9734fd6b6e1e2af8d48a48adf9602045d89535f03e0e53389811660157fe55751d3f616ed095bbc12224832d5de7ffb3cb39e8895686cb1954f58e9d6173bfd47ab6fd80514cdbc3ee87bfce4564416ab5204b109519549c4033868ed667162fc81a7e009af361fc69279ea6d02df626a3d8161db22d7c655a95897e89209b8a08512337157c47fa4df34416c5486cc50ca16bf99fe6faf6abcba2db1aa640af9cdd90aa1a0fd2c23fad087dbba9d2b79b9c4ba08d42ffd7aee12f63313831df486c4c9b504074aa12bab7f58aa82735f22ab3ffb88250147247426ab12e638ce4c61a1d5796e7c7864c15aaaf06ca78900395cf9080f70de87846a3ae512db33c925c4e043f9d421c39395f67735fb1bf430e9c23d4ed485614bc769cc4bd94863fbb2ef5c0bf905698af24434d8cea4b1396f873313299d84f2599a7587fa8d7397b1db7e7bbf096c4f148bbea7d3dc886fd6ead343dadd82ea442c90f3154a2b76b6478b688e1acfd9d6276abf808e4b43ecf57139ed6064d24a1bb5f42763c0a0ef807635d3120be26587c42c4f234dc7fc91f6cc67489049f644c7432bd7fe0c5a8604127b21ce78f9ab54a713a59c99b414fd49279f86299a718f1a8f928fd9f6ea87220de7075fe0d6b2f21caa61e8e496ba716fd964ac42f1658788bff148ce17e1067eb60fcc7dde08c6758b8619d7d915edf2a8e6b7b7457c667e108c65b8ead2d58df073a1cdc291556b182453c2e6510344c2d05155caffb7dabc87d01125f0de771eab550a587be72ebbd429dd7a5f1ad643060af02c23cc5c6c2871169b039ff1a3284999da0d382b082dc234b1fc5639fca5616ac26e790926d42c5cc8e0d354ea3961404edf1d93c5d35aa921a38cec5e056ef44ca621e81b40ff8c221006e3e25e06e9fd620a0169eec76da7061fc41bed5c6a75f5a836d36dd75f82df09b8d1fae50cfa7db1326701d6cbd3281d3a21b3db39c8803f5e21f19b97f283f49d5768caf810e0f9631d6aeac06d08ab1818cd6ce8a9bbf42026924e45feecce4d96ad893b08ce11bf0735b5c9c56dd7630d61ea2281e6a52d061475331f0d54e812e83ccba833715296d8e1cfbfc9d77ded3838ba4a7c11a1b37c1b411560f0755c1567f9b2a594535462a6655aa7042a3e283eac0ca68c301498458b9f01f950187ac9f7d0501867c88430506c6ff8e9340297dfb5563b1270cd4b953247f0aaa8d52ce387f4724809381bcca44da75a5f62fc6b9736a955be1e43975a4ed24ac2c9b7fecc39b9185177c94c013225de21b650982d6fa8c469c9d9fb39efa9473b0181f25482fd0c0899caeb54b9701d4261f1feb03951e01c271a823ce97527a4a5300f9f0959df83761eed6df23ca69b05333ab662417f2945e5777ea94516801cd17a69be7fb7aed4d95fad3fd179059df212730be485e9eaa02ffaf941e193e919c71bcebeb95a3ed45bb1e9c3bb8c4cc6029ed04e87e7fe6dd4bfd4969a8afb88c018183f0adc3b70e214db41b37f81feb929065a65c6f72f2460fa336a54ce131111caf0275787fce5400acf4a2cdc5142550a86b4761fb1ed3f491ba417d8ad9a706d01e1e01566929d28bd024fd9996714b5d722eb75f1004b99283b6c09dd418c95aa53bff9c12ca13ed4c98445db66b5ab015e84b7c9aa2e2771744ad90e68739f985a63527d41addc284df95e539db8b183f0280f51fe697d9bd72bd494f744ec57f86b71140d2709ad4d6aaadb1e0df7d89c3a886a405183fad28f243af0e6bc07c96fc09bfec5729c606da6f7d56248eb370171d21b5fc64fc49e2c684b0c3400f8182891118efe7e4783ee6d87b5a4389854bd8b8dd2c04bef4de2a53c8df48e2d88044f6949cca640af83d2a7bfee5f886674bc841ae3a9779d04d3919006018aaa988f0065f3a2a885f0fbc60440fad1b1c93c92d7976c09596715dd9b4c432d21149b6af25c2fb7f4ee641b15fd8a78cbb5133ff1e3804326f712023de26075fc65cac01e439dc715f105b78aa082dac66a18d161f17acff7278adc3e10322b4b3850c7a778f6ec6ff3b42f6494cd12c8648e50852efca10a4a140cee7f3064b1d6123e277bbe26252851bab8455da50f19093fee3b49e75891ccee61d8120d6e64a91f0396b10a0b143786ceaf00725387ced0450c24e15d756f6d87f93a37973dce60905b1c6cab7c6b44eb9ab0144c22440fb93ba693f7e5f624bff700edafbc4632709d4e44ae9ec411006de9a1834aa76262496cda58a9551127453fbeb7cc8dc9928093665a8eed95cf09b0ec0137929cdebbb58c810dced77a644441ef3f9e02d96770d77c5642e64e88671cff3f775a05881148d2068c8765b0e77788864117446bf95b815cefadcbcd095e5beb96527a2f3241140bd46e0bdfae597e0dfdb45fcb1b12932061b9ad6c6ec94d099fe03e891564d9df7a001757204f9b0b96fedfeb512583dd79e5d43b68dcf55552f6d8a3f3dee8ea45860ad72768810fed71f117453f86aab42d85c81a04b6ad2cec7b64f8ac990e76a06e473f12f646f6b67970b63dccaf93aaf87887dd92026313fc1630fa356c66d226409b30fab3f773416eb3d1b9b33e613d180315abfb10d0c42f021e3ced075d608c7d416ed9db013cbdaaf96b2e2764e0aa5072cd23731101a805e720895682efd8c56b0e49dbd0c1c8d27ba0792e0c67bdde3b877e994b3e9ee035e2dba58d0c1a30d4b1efb0589fce100f7f678a985369f77f1e3d8ea76bcb97e4983c32b9ed91fc1c2d1e1501c85ec383850a1b95f3724f44ca6c5e6768df462a0f2e48fd530c4eb001b1a800579e42732be1d43a04f844e46ba183dee9c5b4d4f062126598e8e6290fc2e9f8e2dcd7a016182253638a2aee1edd4465455373d89caabe8a8fda8b7c164eb9608e24b577e7d791fa4040904ea0a53184b2058c502d3e937086721762dcb12c730316c3bc5ea5926beeac4b91a90c6b877aa13c3dd53a0bbb67e8e358581901b5da9cc63db9a09c24f49106e43b59ad7cebc18dbf5afa17b9c98a3d5a0656b07feb2e9d77dea6eff54e37eb7e7914fc80e3a9aaf48f9295c714d3959204b01a8df527e3edd1816a4679cd73ba863c4e0fc2a0220d5951c9a919ba43af08e7976f65dc97827eac36a92a58f1339b28f0844e65b5c1189663a1e8f87f53546c6ba94354a02f666558790d121914774092a236f0d420c743b963e3fe3c823679eed970db2c0eb82245d9446cd958e30d09d54ae13a119f4cc4c5d0476fdbc5c2a1ce99dc1d415bb22530c29fe07e53628c8f91a3eb6847c10d014a6320563a00ceebc969cb837e9efeacbcb8615b4ae90ced6efcb61ec1652eb1d5a34c3802cab205a5227826c3c6e126b4e820a417743a184083cfdfba793c2e96bbf519c6277584b0ef38bc7fb62bf97bf9f02b9b580ca7a282c513800c372f889153103aa231a2a329dfd74afb71b79430a284a1011c7b9e59460125da3654fd3630e8709a70b29e345006b2acf6674f4c0941ba4768edcea743350435b4ff06d4d04ef8c760716dabba1e0d87475b92c1044995ca807c6225dde07b20365ae61ff63eb1160ce10d4ada4b3449c8ce01467ec2c0539c9244391f3399eff72ab38d7b7d027474e5ed4e785d515bf2af28e160eda869654220724ff424ed2b0b8ff8c9c390ff4a2c2c31ac014048aef7c60bc86a0e064b4a34d269b7898e272314c17638c2f001e10f6fd006be2a4f3425eec6c9e4208f5b0e4763eecbff8310b7e1714c45b1c720ddeddd87b83008bae51c8fc4aa61dc7b94d8e05ad63e5ae4ba873c23a9b7b3c82dd4622cf25a5626d3637124e99dc06291c2f7647f86c7f84aeef50bb5a9099a338678de57682c5b4a88735bccec42b6f024e7ca7decebd0f03637abdc45bc4ea835a2e6d33026743d548b7687ca84d97e19ac96933fbb7b57fcf6604024f4c50f29d82845335f4ff4391bc4a62fc6743feb4ded5517da110465641f6a7c45aa2e25bab0479cb484c8d4d39d023cd7b601beb376463eed2931ed394a03def8c2f1192cc6d2762ac560e6be849ac4254876ef2357b6f789940ec23ab2631bbf2940f357dafaeda7e4f5db1a37ea29324542901e5e7e57b55cd74c58593fb9b5c989ebb60273255a016886acd7fec893673e6ba105de37c116449369db36565b9408f71861fc1ed4e99abbd00ffaae7a81d4be98bd100f0735431bbd239481f989a411691e3ebb6d702db227a83e3f560c09ec4f13001e6700355cc55d9e2ee43076a0e8bfdec6e56548f0381ff17aff8848484a998c732a7359c9123819cd3902f5e758afbd3781fa94640ddb59a1986a94d3f376f7ad2419df578c0ea231d4143772879dc0a48d6fbca42d678e20399324686cb0f7b1b1c26060b7423b32af9aa4e59e79a24f160499f4fcd818f8ef5a0495de739e60d251db02729d147fd17a937e05e6a25ea4e999c2667cb40e6d9e88372a5690d67a62e4b41fb1913411b1831e9116afcd6c0080fc3f027c9e169490c6537bc1a69d137c51adf1ed3e4afb9abd135e6e9264cd6890263be15bb21f72c26021986d730a3d8608573f97072da2fafd2b57ca4618076e569a7cd2fc93d0a97b17afbafb2a2166b825cb884549af7ee719431196ce9f8ad73583b2ea309355650e45d6eaa961321707ab9cbd81fe5a78fdffa99b89b28d8ff8838c110491d454aa45a1fed4a54257f4bf19ed3e7d679f02cbe9c3f479eca45161d1ca16c0800a07626a08937508d1ca539b642f53219993d6b264a3d3cec5176a43c3511fc2af3896ec76cff8093e60b6644334eba8b4113cd20a27d4af70a6b1c15aa5bc2ba7a88fb0714b6cb45b06a9ebbd21534dceb88ebfc8ba08a05bba3c4f0afe79dfe6402953edb4c8b644ff5e9e11f1baa58a56a170e25a513790b54fcbfc6b66b615c6572af3fe6c4a98ae61a6513495c79582fdee65f14fbe3316605c291c9ce9517aedde1e79d56c2cc25739d426f9b85d5edb2a18a88eb76d819a1e7fe080b43827312b8f70c88b960475a9766eba1d6a3b5563007690a918040ca23e701aaee90f11d45a93142584c88582dc9a232b9c091c31c58f8c0b39c51492375e4033314f6ca729b1834d70ab027a3a4dea80458dfd618a82b484ba7650b75e7efec9e199f590f1ea91c593abad494eeda27a13b962667d32ca7ec4a270b2eadef34ebaefef577eca6d6da0c3a37801f109228383fb50c1e1c68127df745ba3f0093aa862468d515bac7509533960a0d038cea8c94461bb9a6ccbda5493e7e508d083d8302cf6c6d879d82374dce9d165d86c83f05374c4540d90fa5cc39a4fb8efe76a3daa5c07cb9b933ed99dd5604f24069086c729855ee553fbe7eca3aed3f7f76784401b0f270569fe233609149c5701cd340a6d5c2ca8c8b1272d16329689b4ba10b4264bbc523cd882a6d9aa77507a0f42ae13afff88ab3cd6e0f3d83af81b3deea0aa0d2ddb31a7509f2ab3cdd5536cde4395c79280220936e3e4eded46c7f9e026e8095ee9e23cc794d0eb0db707cdaf9cbf1b97503f4dcd4ae9980409ab3de6c4b90944b42f011eaf9d851f860b9b2bb45170a998366a64b615322e6492da422e70e88c1fcd733b0ae78682c6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3814bf02e22ee37242811a9294edbfe1"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
